# 모듈

## 정보 은닉과 모듈

### 정보 은닉

- 시스템을 모듈 단위로 분해하기 위한 기본 원리
- 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다는 것

### 모듈

- 변경될 가능성이 있는 비밀을 내부로 감추고, 잘 정의되지 않을 퍼블릭 인터페이스를 외부에 제공해서 내부의 비밀에 접근하지 못하게 한다.

### 모듈이 감춰야할 부분

1. 복잡성
   - 모듈이 너무 복잡한 경우 이해하고 사용하기 어렵다.
   - 외부에 **모듈을 추상화할 수 있는 간단한 인터페이스를 제공**해서 모듈의 복잡도를 낮춘다.
2. 변경 가능성
   - 변경 가능한 설계 결정이 외부에 노출될 경우 실제 변경이 발생했을 때 큰 문제가 생길 가능성이 크다.
   - **변경 발생 시 하나의 모듈만 수정**하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.

</br >

## 모듈의 장점

### 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다

- 모듈을 사용하면 모듈 내부에 정의된 변수르 직접 참조하는 코드의 위치를 모듈 내부로 제한할 수 있다.
  - 어떤 데이터가 변경됐을 때 영향을 받는 함수를 찾기 위해 해당 데이터를 정의한 모듈만 검색하면 됨
- 전체 함수를 일일이 분석할 필요가 없다.
- 데이터 변경으로 인한 파급효과를 제어할 수 있기 때문에 수정 및 변경이 용이하다.

</br> 

### 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다

- 비즈니스 로직(급여 계산)과 사용자 인터페이스(입출력)을 분리한다.
  - 즉, 사용자 인터페이스를 추가하더라도 비즈니스 로직은 변경되지 않는다.

</br >

### 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염(namespace pollution)을 방지한다

- 변수와 함수를 모듈 내부에 위치시키기 때문에 다른 모듈에서도 동일한 이름을 사용할 수 있다.
  - 즉, 전역 네임스페이스의 오염을 방지함과 동시에 이름 충돌의 위험을 완화한다.

</br >

## 모듈의 한계점

### 인스턴스의 개념을 제공하지 않는다

- Employees를 예로 들면 모듈은 단지 회사에 속한 모든 직원 정보를 가지고 있다.
  - 좀 더 높은 수준의 추상화를 위해서는 직원 전체가 아니라 **개별 직원을 독립적인 단위로 나눌 수 있어야 한다**.
  - 다시 말해 다수의 직원 인스턴스가 존재하는 추상화 메커니즘이 필요한 것이다.(추상 데이터 타입)

