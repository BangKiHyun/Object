# 객체 분해

## 프로시저 추상화

- 소프트웨어가 **무엇을 해야하는지** 추상화
- 기능 분해, 알고리즘 분해

## 데이터 추상화

- 소프트웨어가 **무엇을 알아야 하는지를** 추상화

### 데이터 추상화의 2가지 방법

- 데이터를 중심으로 타입을 추상화
  - 추상 데이터 타입이라고 부름
- 데이터를 중심으로 프로시저를 추상화
  - 객체지향이라고 부름

</br >

## 프로시저 추상화와 기능 분해

### 프로시저 추상화

- 프로시저는 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법
- 내부 상세 구현 내용은 모른체 인터페이스만 알면 프로시저를 사용할 수 있다.
- 단점으로 정보은닉 체계를 구축하는데 한계가 있다.

### 하향식 접근법(Top-Down Approach)

- 전통적인 기능 분해 방법이다.
- 시스템을 구성하는 가장 최상위 기능을 정의하고, 이 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법을 말한다.
- 세분화 단계는 위 단계보다 더 구체적이어야 한다. 즉, 정제된 기능을 자신의 바로 상위 기능보다 덜 추상적이어야 한다.

</br >

# 급여 관리 시스템 예제

## 하향식 접근법을 통한 기능 분해

- 최상위 문장
  - 직원의 급여를 계산한다
- 세분화 절차 1
  - 직원의 급여를 계산한다
    - 사용자로부터 소득세율을 입력받는다
    - 직원의 급여를 계산한다
    - 양식에 맞게 결과를 출력한다
- 세분화 절차 2
  - 직원의 급여를 계산한다
    - 사용자로부터 소득세율을 입력받는다
      - "세율을 입력하세요: "라는 문장을 화면에 출력한다
      - 키보르르 통해 세율을 입력받는다
    - 직원의 급여를 계산한다
      - 전역 변수에 저장된 직원의 기본급 정보를 얻는다
      - 급여를 계산한다
    - 양식에 맞게 결과를 출력한다
      - "이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다

기능 분해의 결과는 **최상위 기능을 수행하는 데 필요한 절차들을 실행되는 시간 순서에 따라 나열한 것**

기본적으로 기능 분해는 **책의 목차를 정릴하고 그 안에 내용을 채워 넣는 것과 유사**

</br >

## 구현

### 최상위 문장

~~~java
public class Main {
    public static void main(String[] args) {
        SalaryManagementApplication application = new SalaryManagementApplication();
        application.main("직원C");
    }
}
~~~

### 세분화 절차 1

~~~java
    public void main(String name) {
        double taxRate = getTaxRate();
        double pay = calculatePayFor(name, taxRate);
        System.out.println(describeResult(name, pay));
    }
~~~

### 세분화 절차 2

~~~java
    private static List<String> employees = Arrays.asList("직원A", "직원B", "직원C");
    private static List<Integer> basePays = Arrays.asList(400, 300, 250);    

		private double getTaxRate() {
        System.out.print("세율을 입력하세요: ");
        return SCANNER.nextDouble();
    }

    private double calculatePayFor(String name, double taxRate) {
        int idx = employees.indexOf(name);
        int basePay = basePays.get(idx);
        return basePay - (basePay * taxRate);
    }

    private String describeResult(final String name, final double pay) {
        return String.format("이름: %s, 급여: %f", name, pay);
    }
~~~

### 코드로 본 하향식 기능 분해 과정

- 최상위의 가장 추상적인 메인 함수로 정의
- 메인 함수를 구현 가능한 수준까지 세부적인 단계로 분해

메인 함수를 루트로 하는 '트리'로 표현한 것과 같다.

</br >

## 문제점

### 하나의 메인 함수라는 비현실적인 아이디어

- 어떤 시스템도 최초에 릴리스됐던 당시의 모습을 그대로 유지하지 않음
  - 사용자를 만족시키기 위해 시스템 발전
  - 시스템이 오직 하나의 메인 함수로만 구현된다는 개념과 모순
- 처음에 중요하게 생각했던 메인 함수는 동등하게 중요한 여러 함수들로 전락
  - 어느 시점에 이르면 동등한 여러 시스템의 함수 집합으로 성장

</br >

### 메인 함수의 빈번한 설계

- 하나의 메인 함수를 유일한 정상(top)으로 간주하기 때문에 **새로운 기능을 추가할 때마다 메인 함수 수정**해야 함
  - **기존 코드를 수정하는 것은 항상 새로운 버그를 만들어낼 확률을 높인다!**
- 모든 직원들의 기본급의 총합을 구하는 기능을 추가해야 하는 상황일 때
  - 기존 메인 함수는 직원 각각의 급여를 계산하는 것이 목적이므로 전체 직원들의 **기본급 총액을 계산하는 함수가 들어설 자리가 마땅치 않음**

</br >

### 비즈니스 로직과 사용자 인터페이스의 결합

- 비즈니스 로직
  - 사용자 인터페이스에 비해 변경이 적게 발생
  - 관심사: 급여를 계산
- 사용자 인터페이스
  - 시스템 내에서 자주 변경되는 부분
  - 관심사: 소득세율 입력받아 결과를 화면에 출력

- 하향식 접근법은 비즈니스 로직을 설계하는 초기 단계에 입력 방법과 출력 양식을 함께 고민하도록 강요
- 즉, 사용자 인터페이스와 비즈니스 로직을 한데 섞기 때문에 사용자 인터페이스를 변경한는 경우 비즈니스 로직까지 변경에 영향을 받게 됨.

</br >

### 성급하게 결정된 실행 순서

- 하향식 접근법은 함수를 더 작은 함수로 분해하면 실행 순서를 결정하는 작업
- 즉, 설계를 시작하는 시점이 **무엇(what)이 아닌 어떻게(how)에 집중**
- 중앙집중 제어 스타일
  - 중요한 제어 흐름의 결정이 상위 함수에서 이뤄지고 하위 함수는 상위 함수의 흐름에 따라 적절한 시점에 호출
- 하위 함수는 상위 함수가 강요하는 문맥에 강하게 결합됨(**강한 결합**)
  - 강한 결합도는 시스템을 변경에 취약하게 만들고 이해하기 어렵게 만든다.

</br >

### 데이터 변경으로 인한 파급효과

- 하향식 기능 분해의 가장 큰 문제점으로 **어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어려움**
  - 따라서 데이터 변경으로 인해 어떤 함수가 영향을 받을지 예상하기 어렵다.
- 데이터의 변경으로 인한 영향은 데이터를 직접 참조하는 모든 함수로 퍼진다.

</br >

## 하향식 분해의 유용성

- 하향식 아이디어는 설계가 어느 정도 안정화된 후에 **설계의 다양한 측면을 논리적으로 설명하고 문서화하기에 용이함**
- 즉, 하향식 단계가 시작될 때 문제는 이미 해결됐고, 해결돼야만 하는 세부사항만 존재할 뿐임

