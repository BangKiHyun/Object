# Chapter 4: 설계 품질과 트레이드오프

## 들어가기 전 중요 개념 설명

- 구현: 변경될 가능성이 높은 부분
- 인터페이스: 상대적으로 안정적인 부분

</br >

## 캡슐화

### 캡슐화란?

- 캡슐화란 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류.
- 즉, 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법

### 캡술화의 중요성

- 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수 있음.
- 따라서 변경의 관점에서 설계의 품질을 판단하기 위해 캡슐화를 기준으로 삼을 수 있다.
- 유지보수성의 증가
  - 유지보수성이란 두려움 없이, 주저함 없이, 저항감 없이 코드를 변경할 수 있는 능력
  - 캡슐화를 통해 피해가 발생할 수 있는 가능성을 사전에 방지할 수 있으므로 변경이 자유로워짐. 즉 유지보수하기 쉬워진다.

</br >

## 응집도와 결합도

응집도와 결합도는 구조적 설계 방법이 주도하던 시대에 소프트웨어의 품질을 측정하기 위해 소개된 기준

### 응집도란?

- 응집도란 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타냄
- 높은 응집도: 모듈 내의 요소들이 서로 다른 목적을 위해 긴밀하게 협력
- 낮은 응집도: 모듈 내의 요소들이 서로 다른 목적을 추구

객체지향 관점에서 응집도는 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지를 나타낸다.

### 결합도란?

- **의존성**의 정도를 나타냄
- 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도
- 높은 결합도: 어떠 모듈이 다른 모듈에 대해 너무 자세한 부분까지 알고 있음
- 낮은 결합도: 어떤 모듈이 다른 모듈에 대해 꼭 필요한 지식만 알고 있음

객체지향 관점에서 결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하는지 나타낸다.

### 좋은 설계란?

- 유지보수성이 좋은, 변경용이한 설계
- 좋은 설계를 만들기 위해 **높은 응집도와 낮은 결합도**를 추구해야 한다.
- 즉, 응집도와 결합도는 변경과 관련된다.

### 변경 관점에서의 응집도

- 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도
- 높은 응집도: 하나의 요구사항 변경를 반영하기 위해 오직 하나의 모듈만 수정
- 낮은 응집도: 하나의 원인에 의해 변경해야 하는 부분이 다수의 모듈에 분산돼 있기 때문에 여러 모듈을 동시에 수정

### 변경 관점에서의 결합도

- 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도
- 즉, 모듈을 수정할 때 얼마나 많은 모듈을 함께 수정해야 하는지를 나타냄

</br >

## 캡슐화와 응집도,결합도의 관계

- 캡슐화를 지키면 모듈 안의 응집도는 높아지고 모듈 사이의 결합도는 낮아진다.
- 캡슐화를 위반하면 모듈 안의 응집도는 낮아지고 모듈 사이의 결합도는 높아진다.

결론은 응집도와 결합도를 고려하기전에 먼저 캡슐화를 향상시키기 위해 노력하자!!

</br >

## 데이터 중심 설계와 객체 중심 설계

객체지향 설계에서는 두 가지 방법을 이용해 시스템을 객체로 분할할 수 있다.

1. 상태를 기준으로 분할
2. 책임을 기준으로 분할

여기서는 '상태'와 '데이터'를 동일한 의미로 사용하겠다.

</br >

## 데이터 중심 설게(절차지향)

데이터 중심의 관점에서는 객체는 자신이 포함하고 있는 데이터를 조작하는 데 필요한 오퍼레이션을 정의한다.

즉, 객체를 독립된 데이터로보 보고, 객체의 상태에 초점을 맞춘다.

## 설계 방법

데이터 중심 설계는 객체 내부에 저장되는 데이터를 기반으로 시스템을 분할하는 방법이다.

그러므로 객체가 내부에 저장해야 하는 데이터가 무엇인가의 관점에서 시작한다.

예를들어 영화(Movie)라는 객체를 설계해보면 다음과 같다.

~~~
	public class Movie {
    private String title;
    private Duration runningTime;
    private Money fee;
    private List<DiscountCondition> discountConditionList;

    private MovieType movieType;
    private Money discountAmount;
    private double discountPercent;
}
~~~

영화를 표현하는 가장 기본적인 정보인 제목, 상영시간, 기본 요금을 인스턴스 변수로 포함하고

할인 금액을 계산하는 데 필요한 데이터인 금액 할인 정책, 할인 금액, 비율 할인 정책, 할인 비율이 필요하다. MovieType은 설정된 할인 정책을 알고 있는 데이터다.

### 접근자와 수정자

Movie와 같이 필요한 데이터에서 내부 데이터를 캡슐화하기 위해 접근자(getter)와 수정자(setter)를 추가하여 내부 데이터를 반환하게 할 수 있다.

~~~
public Money getFee() {
	return fee;
}

public void setFee(Money fee) {
	this.fee = fee;
}
~~~

</br >

## 데이터 중심 설계의 문제점

데이터 중심을 설계는 캡슐화를 위반하고 객체의 내부 구현을 인터페이스의 일부로 만든다.

캡슐화를 위반하기 때문에 응집도가 낮고 결합도가 높은 객체를 양산하게 될 가능성이 크다.

## 캡슐화 위반

위에서의 Movie클래스의 내부 상태에 접근하기 위해 getter와 setter를 사용했다. getter와 setter는 캡슐화의 원칙을 지키고 있는 것처럼 보이지만 **getFee와 setFee는 Movie의 내부에 Money 타입의 fee라는 이름의 인스턴스 변수가 존재한다는 사실을 퍼블릭 인터페이스에 노골적으로 나타낸다.**

### 원인

- 객체가 수행할 책임이 아니라 내부에 저장할 데이터에 초점을 맞췄기 때문.
- 객체가 사용될 문맥을 추측할 수밖에 없는 경우 과도한 접근자와 수정자를 가지게 된다.
  - 어떤 상황에서도 해당 객체가 사용될 수 있게 최대한 많은 접근자 메서드를 추가하게 되는 것이다.

> 엘린 홀럽
>
> 접근자와 수정자에 과도하게 의존하는 설계 방식을 '추측에 의한 설계 전략'이라 부른다.

</br >

## 높은 결합도

객체 내부의 구현이 객체의 인터페이스에 드러난다는 것은 클라이언트가 구현에 강하게 결합된다는 것을 의미한다.

즉, 객체의 내부 구현을 변경했음에도 이 인터페이스에 의존하는 다른 클라이언트들도 함께 변경해야 한다.

### 결합도 측면에서 보는 데이터 중심 설계의 단점

- 여러 데이터 객체들을 사용하는 제어 로직(ex: ReservationAgency)이 특정 객체 안에 집중되기 때문에 하나의 제어 객체가 다수의 데이터 객체에 강하게 결합.
- 이 결합도로 인해 어떤 데이터 객체를 변경하더라도 제어 객체를 함께 변경할 수 밖에 없게됨.

## 낮은 응집도

서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도가 낮다고 말한다.

각 모듈의 응집도를 살펴보기 위해서는 코드를 수정하는 이유가 무엇인지 살펴보면 된다.

### 낮은 응집도의 문제

- 변경의 이유가 서로 다른 코드들을 하나의 모듈 안에 뭉쳐놓았기 때문에 변경과 상관이 없는 코드들이 영향을 받게 된다.
  - 대표적인 증상으로 어떤 코드를 수정한 후에 아무런 상관도 없던 코드에 문제가 발생하는 경우가 있다.
  - ex: ReservationAgency에서 새로운 할인 정책을 추가 했을 때 할인 조건에도 영향을 미칠 수 있음

- 하나의 요구사항 변경을 반영하기 위해 동시에 여러 모듈을 수정해야 한다.
  - ex: ReservationAgency에 새로운 할인 정책을 추가하거나 할인 조건을 추가하기 위해 하나 이상의 클래스를 동시에 수정해야 한다.

> 로버튼 마틴
>
> 단일 책임 원칙(SRP): 클래스는 단 한 가지의 변경 이유만 가져한다.
>
> 단일 책임 원칙이라는 맥락에서 '책임'이라는 말인 '변경의 이유'라는 의미로 사용된다. 단일 책임 원칙에서의 책임은 지금까지 살펴본 역할, 책임, 협력에서 이야기하는 책임관느 다르며 변경고 관련된 더 큰 개념을 가르킨다.

</br >

## 캡슐화의 진정한 의미

- **캡슐화는 변할 수 있는 어떤 것이라도 감추는 것**
- 속성의 타입이건, 할인 정책의 종류이건 상관 없이 내부 구현의 변경으로 인해 외부의 객체가 영향을 받는다면 캡슐화를 위반한 것
- 정리하자면 설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화해야 한다.

