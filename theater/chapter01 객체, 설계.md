## chapter 1: 객체, 설계

### 티켓 판매 애플리케이션 구현

#### 시나리오

- 소극장에 관람객들이 들어온다.
- 관람객은 초대장을 소유하고 있는 사람과 안하고 있는 사람으로 나뉜다.
- 초대장을 소유하고 있으면 티켓으로 교환, 소유하고 있지 않으면 돈으로 티켓을 사야한다.



### 소프트웨어 모듈의 세 가지 목적

1. 실행 중에 제대로 동작해야 한다.
   모듈의 존재 이유이다.
   다중 스레드 환경에서도 오류없이 작동하게 만들자!
2. 변경을 위해 존재한다.
   대부분의 모듈은 생명주기 동안 변경되기 때문에 간단한 작업으로 변경이 가능해야 한다.
   객체의 역할과 책임을 잘 분리하자!
3. 코드를 읽는 사람과 의사소통해야 한다.
   모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다.
   즉, 가독성이 좋아야 한다.

정리하자면 **모듈은 제대로 실행돼야 하고, 변경이 용이해야 하며, 이해하기 쉬워야 한다!!**

### 아래 코드의 문제점

```
package theater;

public class Theater {
    
    private final TicketSeller ticketSeller;

    public Theater(TicketSeller ticketSeller) {
        this.ticketSeller = ticketSeller;
    }
    
    public void enter(Audience audience){
        if(audience.getBag().hasInvitation()){
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().setTicket(ticket);
        }else{
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().minusAmount(ticket.getFee());
            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
            audience.getBag().setTicket(ticket);
        }
    }
}
```

위 코드는 필요한 기능을 오류 없이 수행하고 있다. 하지만 변경 용이성과 읽는 사람과의 의사소통 목적을 만족시키지 못한다.

#### enter메서드 동작 설명

1. 소극장 관람객의 가방을 열어 그 안에 초대장이 들어 있는지 확인한다.
2. 들어있으면 판매원은 매표소에 보관돼 있는 티켓을 관람객의 가방으로 옮긴다.
3. 들어있지 않다면 관람객의 가방에서 티켓 금액만큼 현금을 꺼낸다.
4. 티켓 금액을 매표소에 적립한다.
5. 매표소에 보관돼 있는 티켓을 가방 안으로 옮긴다.

#### 이해 가능한 코드

이해 가능한 코드란 그 동작이 우리의 예상에서 크게 벗어나지 않는 코드를 의미한다.

대부분의 사람들이 예상한 동작은

1. 관람객이 직접 자신의 가방에서 초대장을 꺼내 판매원에게 건넨다.
2. 티켓을 구매하는 관람객은 가방 안에서 직접 돈을 꺼내 판매원에게 지불한다.
3. 판매원은 매표소에 있는 티멧을 직접 꺼내 관람객에게 건네고 관람객에게서 직접 돈을 받아 매표소에 보관한다,

코드를 이해하기 어렵게 만든 또 다른 이유는 세부적인 내용들을 한꺼번에 기억하고 있기 때문이다.
enter메서드를 이해하기 위해 Audience, Bag, TickeSeller, TicketOffice의 세부내용까지 다 알고 있어야 한다.

가장 심각한 문제는 Audiecne와 TicketSeller를 변경할 경우 Theater도 함께 변경해야 한다는 점이다.(변경에 취약하다!)
이것은 **객체 사이의 의존성(dependency)**에 관한 문제다. OOP는 서로 의존하면서 협력하는 객체들의 공동체를 구축해야 한다.
즉, 의존성을 완전히 없애는 것이 아닌, **최소한의 의존성만 유지**하는 것이 정답이다.

**객체 사이의 의존성이 심한 경우 결합도(coupling)가 높다**고 말한다.
객체들이 합리적인 수준으로 의존할 경우에는 결합도가 낮다고 말한다.
즉, **결합도가 높을수록 변경에 취약한 코드**일 확률이 높다.



### 캡슐화(encapsulation)

개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것

### 목적

변경하기 쉬운 객체를 만드는 것이다.
풀어 말하면, 캡슐화를 통해 객체 내부로의 접근 제한을 한다. 즉, 결합도를 낮춰서(의존성을 제거해서) 변경을 용이하게 만든다.

### 응집도(cohesion)

프로그램의 한 요소가 해당 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉쳐있는지 나타내는 정도

자신과 밀접하게 연관된 작업만 수행하고, 연관성이 없는 작업은 다른 객체에게 위임하는 객체를 응집도가 높다고 말한다.
즉, 객체의 응집도를 높이기 위해서는 **객체 스스로 자신의 데이터를 책임**져야 한다.

핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지(메서드)를 통해서만 상호작용하도록 만드는 것이 중요하다.



### 절차지향과 객체지향

#### 서론

수정하기 전 Theater의 enter메서드에서 Audience, TicketSeller등을 이용해 관람객을 입장시키는 절차를 구현했다.
Audience, TicketSeller, Bag, TicketOffice는 관람객을 입장시키는 데 필요한 정보를 제공하는 **데이터(Data)**이고,
Theater의 enter 메서드는 데이터에대한 처리를 담당하는 **프로세스(Process)**다.

#### 절차지향

서론에서 말한 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍이라 한다.
모든 처리가 하나의 클래스 안에 위치하고 나머지 클래스는 데이터의 역할만 수행하는 모듈은 절차지향적이라 한다.

- 단점
  - 코드를 읽는 사람과 원활하게 의사소통하지 못한다.
  - 데이터의 변경으로 인한 영향을 지역적으로 고립시키기 어렵다.
    (결합도가 강하기 떄문에)

### 객체지향

데이터와 프로세스가 **동일한 모듈 내부에 위치**하도록 프로그래밍 하는 방식을 객체지향 프로그래밍이라 한다.
객체지향 설계의 핵심은 캡슐화를 이용해 최소한의 의존성을 갖게 함으로써 객체 사이의 결합도를 낮추는 것이다.

- 장점
  - 코드를 읽는 사람과 원활하게 의사소통을 할 수 있다.
    (자신의 문제를 스스로 처리해야 하기 때문에)
  - 객체 내부의 변경이 객체 외부에 영향을 끼치지 않아 변경에 용이하다.



### 책임의 이동

절차지향과 객체지향의 차이를 만드는 것은 책임의 이동이다.

처음 만든 Theater클래스를 보면 책임이 Theater에 집중돼 있다.
개선한 후의 코드를 보면, Theater에 몰려 있던 책임이 각각의 객체로 이동한 것을 볼 수 있다.(책임의 이동)

객체지향 설계에서는 각각의 객체에 책임이 적절하게 분배된다.
즉, 자신을 스스로 책임진다.



### 결론

객체지향 프로그래밍을 해라!

- 객체지향 프로그래밍은 의존성을 효율적으로 통제할 수 있다.
- 객체간 결합도가 낮기 때문에 요구사항 변경에 유연하게 대처할 수 있다.
- 각각의 객체마다 책임을 갖고 있기 때문에 코드의 이해가 쉽다.